import os
import json
import zipfile
import tarfile
import uuid
from datetime import datetime
from typing import Dict, Any, Optional
from pathlib import Path

from models import CreatePackageRequest, DependencyModel


def generate_package_id() -> str:
    """Generate a unique package ID using UUID4"""
    return str(uuid.uuid4())


def create_requirements_txt(dependencies: list[DependencyModel]) -> str:
    """Create requirements.txt content from dependencies"""
    if not dependencies:
        return "# No dependencies specified\n"
    
    lines = ["# Generated by ReproPack\n"]
    for dep in dependencies:
        lines.append(dep.to_pip_format())
    
    return "\n".join(lines)


def create_environment_file(env_vars: Dict[str, str]) -> str:
    """Create .env file content from environment variables"""
    if not env_vars:
        return "# No environment variables specified\n"
    
    lines = ["# Generated by ReproPack", "# Copy this file to .env in your project"]
    for key, value in env_vars.items():
        lines.append(f"{key}={value}")
    
    return "\n".join(lines)


def create_setup_script(setup_scripts: list[str], dependencies: list[DependencyModel]) -> str:
    """Create setup.sh/setup.bat script content"""
    lines = [
        "#!/bin/bash",
        "# Generated by ReproPack - Setup Script",
        "# This script sets up the development environment",
        "",
        "echo 'Setting up ReproPack environment...'",
        ""
    ]
    
    # Add Python environment setup
    if dependencies:
        lines.extend([
            "# Install Python dependencies",
            "echo 'Installing Python dependencies...'",
            "pip install -r requirements.txt",
            ""
        ])
    
    # Add custom setup scripts
    if setup_scripts:
        lines.extend([
            "# Custom setup scripts",
            "echo 'Running custom setup scripts...'",
        ])
        for script in setup_scripts:
            lines.append(f"echo 'Running: {script}'")
            lines.append(script)
            lines.append("")
    
    lines.extend([
        "echo 'Setup complete!'",
        "echo 'Environment is ready for development.'"
    ])
    
    return "\n".join(lines)


def create_readme(request: CreatePackageRequest) -> str:
    """Create README.md content"""
    lines = [
        f"# {request.project_name}",
        "",
        f"**Author:** {request.author}",
        f"**Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
        ""
    ]
    
    if request.description:
        lines.extend([
            "## Description",
            "",
            request.description,
            ""
        ])
    
    lines.extend([
        "## Setup Instructions",
        "",
        "This package was created with ReproPack to ensure reproducible development environments.",
        "",
        "### Prerequisites",
        "- Python 3.8+ installed",
        "- pip package manager",
        ""
    ])
    
    if request.dependencies:
        lines.extend([
            "### Dependencies",
            "",
            f"This project requires {len(request.dependencies)} Python packages:",
            ""
        ])
        for dep in request.dependencies:
            lines.append(f"- {dep.name} ({dep.version})")
        lines.append("")
    
    if request.environment_variables:
        lines.extend([
            "### Environment Variables",
            "",
            "The following environment variables need to be set:",
            ""
        ])
        for key, value in request.environment_variables.items():
            lines.append(f"- `{key}`: {value}")
        lines.append("")
        lines.extend([
            "Copy the `.env.example` file to `.env` and update the values as needed.",
            ""
        ])
    
    lines.extend([
        "### Quick Start",
        "",
        "1. Extract this package to your desired directory",
        "2. Run the setup script:",
        "   ```bash",
        "   chmod +x setup.sh",
        "   ./setup.sh",
        "   ```",
        "3. If you have environment variables, copy `.env.example` to `.env`:",
        "   ```bash",
        "   cp .env.example .env",
        "   ```",
        ""
    ])
    
    if request.dataset_links:
        lines.extend([
            "### Dataset Links",
            "",
            "The following datasets are referenced in this project:",
            ""
        ])
        for i, link in enumerate(request.dataset_links, 1):
            lines.append(f"{i}. {link}")
        lines.append("")
    
    if request.setup_scripts:
        lines.extend([
            "### Custom Setup Scripts",
            "",
            "The following custom scripts will be executed during setup:",
            ""
        ])
        for script in request.setup_scripts:
            lines.append(f"- `{script}`")
        lines.append("")
    
    if request.instructions:
        lines.extend([
            "### Additional Instructions",
            "",
            request.instructions,
            ""
        ])
    
    lines.extend([
        "## Troubleshooting",
        "",
        "If you encounter issues:",
        "1. Ensure Python 3.8+ is installed",
        "2. Check that pip is up to date: `pip install --upgrade pip`",
        "3. If dependencies fail to install, try using a virtual environment:",
        "   ```bash",
        "   python -m venv venv",
        "   source venv/bin/activate  # On Windows: venv\\Scripts\\activate",
        "   pip install -r requirements.txt",
        "   ```",
        "",
        "---",
        "*Generated by ReproPack - Reproducible Development Environments*"
    ])
    
    return "\n".join(lines)


def create_metadata_json(request: CreatePackageRequest, package_id: str) -> str:
    """Create metadata.json content"""
    metadata = {
        "package_id": package_id,
        "project_name": request.project_name,
        "author": request.author,
        "description": request.description,
        "created_at": datetime.now().isoformat(),
        "dependencies": [
            {
                "name": dep.name,
                "version": dep.version,
                "pip_format": dep.to_pip_format()
            }
            for dep in request.dependencies
        ],
        "environment_variables": request.environment_variables,
        "setup_scripts": request.setup_scripts,
        "dataset_links": request.dataset_links,
        "instructions": request.instructions,
        "repropack_version": "1.0.0"
    }
    
    return json.dumps(metadata, indent=2)


def create_package_archive(request: CreatePackageRequest, package_id: str, packages_dir: str) -> tuple[str, int]:
    """Create a compressed package archive with all necessary files"""
    
    # Create package filename
    safe_project_name = "".join(c for c in request.project_name if c.isalnum() or c in ('-', '_')).strip()
    package_filename = f"{safe_project_name}_{package_id}.zip"
    package_path = os.path.join(packages_dir, package_filename)
    
    # Create the zip file
    with zipfile.ZipFile(package_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
        
        # Add README.md
        readme_content = create_readme(request)
        zipf.writestr("README.md", readme_content)
        
        # Add requirements.txt
        requirements_content = create_requirements_txt(request.dependencies)
        zipf.writestr("requirements.txt", requirements_content)
        
        # Add .env.example
        env_content = create_environment_file(request.environment_variables)
        zipf.writestr(".env.example", env_content)
        
        # Add setup script
        setup_content = create_setup_script(request.setup_scripts, request.dependencies)
        zipf.writestr("setup.sh", setup_content)
        
        # Add metadata.json
        metadata_content = create_metadata_json(request, package_id)
        zipf.writestr("metadata.json", metadata_content)
    
    # Get file size
    file_size = os.path.getsize(package_path)
    
    return package_path, file_size


def get_package_metadata_from_file(package_path: str) -> Optional[Dict[str, Any]]:
    """Extract metadata from a package file"""
    try:
        with zipfile.ZipFile(package_path, 'r') as zipf:
            if 'metadata.json' in zipf.namelist():
                metadata_content = zipf.read('metadata.json').decode('utf-8')
                return json.loads(metadata_content)
    except (zipfile.BadZipFile, json.JSONDecodeError, KeyError):
        pass
    return None


def validate_pip_dependencies(dependencies: list[DependencyModel]) -> list[str]:
    """Validate that dependencies follow pip freeze style format"""
    errors = []
    
    for dep in dependencies:
        # Basic validation for package name
        if not dep.name or not dep.name.replace('-', '').replace('_', '').replace('.', '').isalnum():
            errors.append(f"Invalid package name: {dep.name}")
        
        # Basic validation for version format
        if not dep.version:
            errors.append(f"Missing version for package: {dep.name}")
        elif not any(char in dep.version for char in ['=', '>', '<', '~', '!']):
            # If no version operators, assume exact version
            if not dep.version.replace('.', '').replace('-', '').replace('_', '').isalnum():
                errors.append(f"Invalid version format for {dep.name}: {dep.version}")
    
    return errors
